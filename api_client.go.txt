// TODO: 後で作る 220507 土 09:48:38

// package fetch
//
// import (
// 	"bytes"
// 	"encoding/json"
// 	"fmt"
// 	"io"
// 	"net/http"
// 	"path/filepath"
//
// 	"github.com/nkmr-jp/zl"
// )
//
// const baseUrl = "https://api.cryptowat.ch/markets"
//
// type ApiClient struct {
// 	pathArg   string
// 	outputDir string
// 	filePath  string
// }
//
//
// func newGetCmd(pathArg string) *ApiClient {
// 	dir := rootCmdOption.Root + "/" + "get/api.cryptowat.ch/markets"
// 	outDir := dir + "/" + pathArg
// 	return &ApiClient{
// 		pathArg:   pathArg,
// 		outputDir: outDir,
// 		filePath:  outDir + "/" + filepath.Base(pathArg) + core.Date(getCmdOption.Date) + ".json",
// 	}
// }
//
// func getRunner(cmd *cobra.Command, args []string) {
// 	newCmd := newGetCmd(args[0])
// 	newCmd.run()
// }
//
// func (c *GetCmd) run() {
// 	if err := file.MakeDir(c.outputDir); err != nil {
// 		zl.Error("MAKE_DIR_ERROR", err)
// 	}
// 	ret, err := c.get()
// 	if err != nil {
// 		zl.Error("GET_ERROR", err)
// 	}
// 	if !rootCmdOption.Silent {
// 		fmt.Println(*ret)
// 	}
// 	if err := file.SaveFile(c.filePath, *ret); err != nil {
// 		zl.Error("SAVE_ERROR", err)
// 	}
// }
//
// func (c *GetCmd) get() (*string, error) {
// 	res, err := http.Get(baseUrl + "/" + c.pathArg)
// 	defer func() {
// 		if err := res.Body.Close(); err != nil {
// 			zl.Error("HTTP_CLOSE_ERROR", err)
// 		}
// 	}()
//
// 	if err != nil {
// 		return nil, err
// 	}
//
// 	ret, err := io.ReadAll(res.Body)
// 	if err != nil {
// 		return nil, err
// 	}
// 	if getCmdOption.Minify {
// 		retStr := string(ret)
// 		return &retStr, nil
// 	} else {
// 		var buf bytes.Buffer
// 		if err := json.Indent(&buf, ret, "", "  "); err != nil {
// 			panic(err)
// 		}
// 		indentJson := buf.String()
// 		return &indentJson, nil
// 	}
// }
